import os
import sys
import copy
import urllib.parse
import argparse
from datetime import date, datetime
import traceback

EXPLOIT_STRINGS = ['${jndi:ldap:/', '${jndi:rmi:/', '${jndi:ldaps:/', '${jndi:dns:/']
DEFAULT_PATHS = ['/var/log', '/storage/log/vmware', '/var/atlassian/application-data/jira/log']

def check_line(line, deconstructed_list):
    line = urllib.parse.unquote(line)
    linechars = list(line)
    # temporary detection pad
    dp = copy.deepcopy(deconstructed_list)
    # Walk over characters
    for c in linechars:
        for detection_string in dp:
            # If the character in the line matches the character in the detection
            if c == dp[detection_string]["chars"][dp[detection_string]["level"]]:
                dp[detection_string]["level"] += 1
                dp[detection_string]["current_distance"] = 0
            # If level > 0 count distance to the last char
            if dp[detection_string]["level"] > 0:
                dp[detection_string]["current_distance"] += 1
                # If distance is too big, reset level to zero
                if dp[detection_string]["current_distance"] > dp[detection_string]["maximum_distance"]:
                   dp[detection_string]["current_distance"] = 0
                   dp[detection_string]["level"] = 0
            # Is the pad completely empty?
            if len(dp[detection_string]["chars"]) == dp[detection_string]["level"]:
                return detection_string

def scan_path(path, deconstructed_list, debug):
    number_of_detections = 0
    # Loop over files
    for root, directories, files in os.walk(path, followlinks=False):
        for filename in files:
            file_path = os.path.join(root, filename)
            if debug:
                print("Processing %s ..." % file_path)
            try:
                with open(file_path, 'r') as logfile:
                    c = 0
                    for line in logfile:
                        c += 1
                        result = check_line(line.lower(), deconstructed_list)
                        if result:
                            number_of_detections += 1
                            print("Exploitation attempt detected FILE: %s LINE_NUMBER: %d LINE: %s DEOBFUSCATED_STRING: %s" %
                            (file_path, c, line.rstrip(), result))
            except UnicodeDecodeError as e:
                if args.debug:
                    print("Can't process FILE: %s REASON: most likely not an ASCII based log file" % file_path)
            except Exception as e:
                print("Cant process the FILE: %s REASON: %s" % (file_path, traceback.print_exc()))
    # Result
    if number_of_detections > 0:
        print("Warning, exploitation attempts detected in PATH: %s" % (number_of_detections, path))
    else:
        print("No Log4Shell exploitation attempts detected in path PATH: %s" % path)
    return number_of_detections

def prepare_detections(maximum_distance):
    deconstructed_list = {}
    for ds in DETECTION_STRINGS:
        deconstructed_list[ds] = {}
        deconstructed_list[ds] = {
            "chars": list(ds),
            "maximum_distance": maximum_distance,
            "current_distance": 0,
            "level": 0
        }
    return deconstructed_list

if __name__ == '__main__':

    print("Objective: Detect exploitation attempts on the log4j2 RCE")
    print("NOTE: The data must have been logged prior for the script to find exploitation attempts")
    parser = argparse.ArgumentParser(description='Log4Shell Exploitation Detection')
    parser.add_argument('-p', nargs='+', help='Folder path to scan', metavar='path', default='')
    parser.add_argument('-d', help='Maximum distance between characters', metavar='maxdis', default=30)
    parser.add_argument('--defaultpaths', action='store_true', default=False, help='Scan a set of default paths that usually contain relevant log files.')
    parser.add_argument('--debug', action='store_true', default=False, help='Debug output')

    args = parser.parse_args()

    if not args.p and not args.defaultpaths:
        parser.print_help(sys.stderr)
        print("")
        print("Please provide at least one Path to scan or use --defaultpaths to scan common relevant folders")
        sys.exit(1)


    dateTimeObj = datetime.now()
    print("Scan initiated on DATE: %s" % dateTimeObj)

    # Prepare the detection pads
    deconstructed_list = prepare_detections(int(args.d))

    # Counter
    all_detections = 0

    # Scan paths
    paths = args.p
    if args.defaultpaths:
        paths = DEFAULT_PATHS
    for path in paths:
        if not os.path.isdir(path):
            if not args.defaultpaths:
                print("The specified Path %s doesn't exist" % path)
            continue
        print("Scanning the FOLDER: %s ..." % path)
        detections = scan_path(path, deconstructed_list, args.debug)
        all_detections += detections

    # Finish
    if all_detections > 0:
        print("Warning: %d Exploitation attempts detected in the scan results" % all_detections)
    else:
        print("No exploitation attempts detected in the scan results")
    dateTimeObj = datetime.now()
    print("Scan finished on DATE: %s" % dateTimeObj)
